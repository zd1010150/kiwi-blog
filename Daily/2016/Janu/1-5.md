###1.gulp的入门使用
[http://www.w3ctrain.com/2015/12/22/gulp-for-beginners/](http://www.w3ctrain.com/2015/12/22/gulp-for-beginners/)
###2.react的gulp配置
###3.node的Buffer对象
在utf-8中汉字占有3个16进制,
###4.apache的ab测试，
```ab -c 100 -t 100 -n 1000 url ;-c是并发数，-n是请求数(使用超烂的)，-t 超时时间```
####5.请求数（n）和并发数(c)的联系

```
不是同一个概念，但它们之间有联系： 
设平均响应时间为t(单位为毫秒), 并发量为c，每秒处理请求数为q，则： 
q = (1000/t) * c 
就是这个关系； 
想要升高q，就只有两条路：1) 降低t 2) 升高c 
对于'1', 只能靠优化代码实现，只能尽量做，往往提升有限； 
对于'2', 通常c与你服务器程序的请求处理模型有关，如果你服务器程序是“一个线程对应一个请求”的模式，那么c的最大值就受制于你能支撑多少个线程；如果是“一个进程对应一个请求”的模式，那么c的最大值则受制于最大进程数；

在升高c的过程中，不得不注意的一点是，线程/进程数越多，上下文切换、线程/进程调度开销会增大，这会显著间接地增大t的值从而不能让q跟着c的值等比升高, 所以一味增大c通常也不会有好结果，最合适的c值应该根据实测试验得出

另外，还有一种特殊情况：若业务决定了该服务器提供的服务具有“小数据量、较长返回时间”的特征，即这是一个不忙、但很慢的业务类型，那么可以采用NIO模式提供服务，比如nginx默认就采用nio模式； 
在这种模式下，c值不再与线程/进程数相关，而仅仅与“socket连接数”相关，通常“socket连接数”可以非常大，在经过特殊配置的linux服务器上，可以同时支撑百万级别的socket连接数，在这种情况下c可以达到100w; 
在如此高的c值之下，就算t再大，也可以支撑出一个很高的q，同时真正的线程/进程数可以只开到跟cpu核数一致，以求最大化cpu利用率; 
当然这一切的前提是该业务具有“小数据量、较长返回时间”的特征
```

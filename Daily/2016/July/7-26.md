###1.每日一文-[]()

###2.技术点滴

####2.1 es6中的let会绑定变量的访问性，限制在当前的块级作用域。let 申明的变量不具有变量提升,并且存在暂死性区域（即只有声明之后才能访问，在声明之前访问会报错）。不能重复声明两个相同名字的变量。const和let是一样的；const的变量不可重新赋值而已（注意引用类型存的是地址，地址不能改变，但是地址的内容可以改变）；

####2.2 es5中规定不能在块级作用域中声明函数（浏览器并没有遵守），但是es6中可以在块级作用域中声明函数，`由于环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。`

####2.3 let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，`从ES6开始，全局变量将逐步与全局对象的属性脱钩`。
####2.4 Symbol
* js第七种数据类型，前6种，number,string,bool,object,undefined,null..
* 如果一个变量等于什么值不重要，关键是不要与其他值冲突，这个时候就适合使用Symbol

####2.5 class
* 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。
* 使用Symbol来构造私有变量，外面的变量没法访问
* 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。
* ECMAScript 原生的构造函数：

```
Boolean()
Number()
String()
Array()
Date()
Function()
RegExp()
Error()
Object()
这些构造函数在es5中都是无法继承的，但是在es6中可以继承。


```
* 静态方法

####2.5 原型
* 实例可以访问原型中的值，却不能通过实例重写原型中的值。
* Object.getPrototypeOf(person1)会返回person1的原型对象，Person.prototype.isPrototypeof(person1) 会判断person1的是否是Person的实例
* person1.hasOwnProperty() 会判断该属性是实例属性，还是原型属性
* Object.keys(person1) 返回person1的全部实例属性
* 一句话描述原型链：将一个对象的实例，赋值给另一个对象的原型属性，实现继承。

###3.业务知识

####3.1 

####3.2

####3.3

####3.4

###4.心得感悟

####4.1

####4.2

####4.3

####4.4
###5.单词
